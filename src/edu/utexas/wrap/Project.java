/*
    wrap - free and open-source urban transportation modeling software
    Copyright (C) 2017 the wrap project, The University of Texas at Austin

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package edu.utexas.wrap;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Function;
import java.util.function.ToDoubleFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import edu.utexas.wrap.assignment.Assigner;
import edu.utexas.wrap.assignment.BasicStaticAssigner;
import edu.utexas.wrap.assignment.bush.StreamPassthroughAssigner;
import edu.utexas.wrap.marketsegmentation.DummyPurpose;
import edu.utexas.wrap.marketsegmentation.Market;
import edu.utexas.wrap.modechoice.Mode;
import edu.utexas.wrap.net.AreaClass;
import edu.utexas.wrap.net.Link;
import edu.utexas.wrap.net.NetworkSkim;
import edu.utexas.wrap.net.TravelSurveyZone;
import edu.utexas.wrap.util.io.SkimFactory;
import edu.utexas.wrap.util.io.output.FilePassthroughDummyAssigner;

/** A high-level representation of a multi-market, multi-purpose travel demand model. This class 
 * defines the set of TravelSurveyZones for which demand should be modeled, as well as the Market
 * instances which travel among these zones. Instances of this class may also define a number of
 * Assigner instances which consume ODProfiles generated by the Markets' Purposes, as well as an
 * initial set of NetworkSkims which may be relevant in ODProfile creation. These skims should be
 * updated by the Assigners after their termination.
 * 
 * The Project should define a project directory. This directory should contain all data relevant
 * to the Project, as it will serve as the point against which all relative paths will be resolved.
 * 
 * @author William
 *
 */
public class Project implements Runnable {
	private final Properties props;
	private Map<Integer, TravelSurveyZone> zones;
	private final Path projDir;
	private String name;
	
	/**Project constructor from a Properties file (*.wrp)
	 * @param projFile the location of a Project Properties (*.wrp) file
	 * @throws IOException if the file located by {@code projFile} does not exist or is corrupt
	 */
	public Project(Path projFile) throws IOException, NullPointerException {
		props = new Properties();
		name = projFile.getFileName().toString();
		projDir = projFile.getParent();
	}

	public void loadPropsFromFile() throws IOException {
		props.load(Files.newInputStream(projDir.resolve(name)));
	}

	public void loadZones() throws IOException {
		BufferedReader reader = Files.newBufferedReader(projDir.resolve(props.getProperty("network.zones")));
		reader.readLine();
		AtomicInteger idx = new AtomicInteger(0);

		zones = reader.lines()
				.map(string -> string.split(","))
				.collect(Collectors.toMap(
						args -> Integer.parseInt(args[0]), 
						args -> new TravelSurveyZone(Integer.parseInt(args[0]),idx.getAndIncrement(),AreaClass.values()[Integer.parseInt(args[1])-1])));
	}

	/**Read a list of Market ids from the Project Properties, then load the
	 * corresponding Markets from the corresponding file. 
	 * 
	 * The list of Markets is
	 * defined with the Property key {@code markets.ids}; for each id {@code foo} in
	 * this list, a corresponding key {@code markets.foo.file} must be defined. The 
	 * {@code .file} should be a relative path from the Project directory to a file
	 * (*.wrm) containing the Market Properties associated with this id. 
	 * 
	 * @return a Collection of initialized Markets read from files
	 */
	private Collection<Market> loadMarkets(){
		System.out.println("Reading Market configurations");

		String projNames = props.getProperty("markets.ids");
		
		if (projNames == null) 
			throw new RuntimeException("No markets specified in project properties. Define at least one market");
		
		else return 
				Stream.of(projNames.split(","))
				.map(name -> {
					try {
						return new Market(projDir.resolve(props.getProperty("markets."+name+".file")), zones);
					} catch (IOException e) {
						System.err.println("Could not load trip purposes for "+name);
						e.printStackTrace();
						return null;
					}
				})
				.collect(Collectors.toSet());
	}
	
	/**
	 * @return a Collection of DummyPurposes which are not affiliated with any particular Market
	 */
	private Collection<DummyPurpose> getDummyPurposes() {
		// TODO Auto-generated method stub
		String dummyNames = props.getProperty("dummies.ids");
		
		if (dummyNames == null) return Collections.emptySet();
		else return Stream.of(dummyNames.split(","))
				.map(name ->{
					try {
						return new DummyPurpose(projDir.resolve(props.getProperty("dummies."+name+".file")), zones);
					} catch (IOException e) {
						System.out.println("Could not load dummy trip purpose "+name);
						e.printStackTrace();
						return null;
					}
				})
				.collect(Collectors.toSet());
	}
	
	/**Read a list of Assigner ids from the Project Properties, then load the
	 * corresponding Assigners according to their definition. 
	 * 
	 * The list of Assigners is
	 * defined with the Property key {@code assigners.ids}; for each id {@code foo} in
	 * the list, a corresponding key {@code assigners.foo.class} must be defined. The
	 * @{code .class} should be an available Assigner implementation. Depending on the
	 * Assigner class specified, an additional key {@code assigners.foo.file} may 
	 * define a relative path from the Project directory to a file (*.wrapr) containing
	 * the Assigner Properties associated with this id.
	 * 
	 * @return a Map from an Assigner's id to newly-generated instance.
	 */
	private Map<String,Assigner> loadAssigners(){
		System.out.println("Reading Assigner configurations");

		return getAssignerIDs().stream()
		.collect(Collectors.toMap(Function.identity(), id -> initializeAssigner(id)));
	}
	
	/**Read a list of NetworkSkim ids from the Project Properties, then load the
	 * corresponding NetworkSkims from the corresponding file. 
	 * 
	 * The list of NetworkSkims is defined with the Property key {@code skims.ids}; 
	 * for each id {@code foo} in the list, a corresponding key {@code skims.foo.file} 
	 * must be defined. The {@code .file} should be a relative path from the Project 
	 * directory to a file (*.csv) containing the data associated with the initial cost
	 * skims to be used in building the Project's ODProfiles
	 *  
	 * the ODProfiles of the project.
	 * 
	 * @return a Map from a NetworkSkim's id to its newly-generated instance
	 */
	private Map<String,NetworkSkim> loadInitialSkims(){
		System.out.println("Reading initial NetworkSkims");
		
		return getSkimIDs().stream()
				.parallel()
				.collect(
						Collectors.toMap(
								Function.identity(), 
								id -> SkimFactory.readSkimFile(
										projDir.resolve(props.getProperty("skims."+id+".file")), 
										false, 
										zones
										)
								)
						)
		;
	}
	
	/**Read a list of NetworkSkim ids from the Project Properties, then get the updated
	 * NetworkSkims from their associated Assigners. 
	 * 
	 * The list of NetworkSkims is defined with the Property key {@code skims.ids};
	 * for each id {@code foo} in the list, a corresponding key {@code skims.foo.assigner}
	 * must be defined. The {@code .assigner} should be an Assigner id defined in the
	 * {@code assigners.ids} property. Additionally, the key {@code skims.foo.function}
	 * specifies the cost function to be used by the Assigner in calculating the updated 
	 * cost skim.
	 * 
	 * @param assigners a Map from Assigner ids to their current instance
	 * @return a Map from NetworkSkim ids to their updated instance
	 */
	private Map<String,NetworkSkim> updateFeedbackSkims(Map<String,Assigner> assigners){
		System.out.println("Updating NetworkSkims");

		return getSkimIDs().stream()
		.parallel()
		.collect(
				Collectors.toMap(
						Function.identity(),
						id ->{
							Assigner assigner = assigners.get(props.getProperty("skims."+id+".assigner"));
							ToDoubleFunction<Link> func;
							switch (props.getProperty("skims."+id+".function")) {
							case "travelTimeSingleOcc":
								func = (Link x) -> 
									x.allowsClass(Mode.SINGLE_OCC)? x.getTravelTime() : Double.MAX_VALUE;
									break;
							default:
								System.err.println("Skim funciton not yet implemented. Reverting to travel time");
							case "travelTime":
								func = Link::getTravelTime;
							}
							return assigner.getSkim(func);
						}
						)
				);

	}

	private Assigner initializeAssigner(String id) {
		try {

			switch (props.getProperty("assigners."+id+".class")) {
			case "stream":
				return new StreamPassthroughAssigner(
						projDir.resolve(props.getProperty("assigners."+id+".file"))
						);


			case "bush":
				return BasicStaticAssigner.fromPropsFile(
						projDir.resolve(props.getProperty("assigners."+id+".file")),
						zones
						);
			case "file":
				return new FilePassthroughDummyAssigner(projDir.resolve(props.getProperty("assigners."+id+".file")),zones);
			default:
				throw new RuntimeException("Not yet implemented");
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}

	
	/**
	 * @param assigners
	 */
	private void output(Map<String,Assigner> assigners) {
		// TODO Auto-generated method stub
		Map<String,NetworkSkim> finalSkims = updateFeedbackSkims(assigners);
		System.out.println("Printing final skims");
		finalSkims.entrySet().stream()
		.filter(entry -> Boolean.parseBoolean(props.getProperty("skims."+entry.getKey()+".overwrite")))
		.forEach(
				entry -> SkimFactory.outputCSV(
						finalSkims.get(entry.getKey()),
						projDir.resolve(props.getProperty("skims."+entry.getKey()+".file")),
						zones.values()
						)
				);
		
		
		System.out.println("Printing final flows");
		assigners.forEach((id, assigner) -> {
			assigner.outputFlows(projDir.resolve(id+"flows.csv"));
		});

	}
	
	/**
	 *
	 */
	public String toString() {
		return name;
	}

	public Path getDirectory() {
		return projDir;
	}
	
	@Override
	public void run() {
		Collection<Market> markets = loadMarkets();
		Collection<DummyPurpose> dummies = getDummyPurposes();
		

		Map<String,Assigner> assigners = null;
		
		for (int i = 0; i < getMaxIterations(); i++) {
			System.out.println("Beginning feedback iteration "+i);
			assigners = loadAssigners();
			
			//Update skims and redistribute
			Map<String,NetworkSkim> skims = i == 0? loadInitialSkims() : updateFeedbackSkims(assigners);
			//TODO project should have skims
			markets.parallelStream().forEach(market -> market.updateSkims(skims));
			
			
			Collection<Assigner> ac = assigners.values();

			System.out.println("Calculating disaggregated ODProfiles");
			Stream.concat(
					markets.parallelStream()
					.flatMap(market -> market.getODProfiles()),
					dummies.parallelStream()
					.flatMap(dummy -> dummy.getODProfiles())
					)
			.forEach(
					od -> 
					ac.stream().forEach(assigner -> assigner.process(od))
					);

			
			System.out.println("Starting assignment");
			ac.stream().forEach(Assigner::run);
			

			
		}
		
		System.out.println("Feedback loop(s) completed");
		
		output(assigners);
		
		
		System.out.println("Done");
	}

	public Integer getMaxIterations() {
		// TODO Auto-generated method stub
		return Integer.parseInt(props.getProperty("feedbackIters","1"));
	}

	public List<String> getSkimIDs() {
		// TODO Auto-generated method stub
		String prop = props.getProperty("skims.ids");
		if (prop == null) return new ArrayList<String>();
		String[] ids = prop.split(",");
		return new ArrayList<String>(List.of(ids));
	}

	public List<String> getAssignerIDs() {
		// TODO Auto-generated method stub
		String params = props.getProperty("assigners.ids");
		if (params == null || params.isBlank()) return new ArrayList<String>();
		return new ArrayList<String>(List.of(params.split(",")));
	}

	public String getSkimFile(String skimID) {
		return props.getProperty("skims."+skimID+".file");
	}

	public String getSkimAssigner(String skimID) {
		return props.getProperty("skims."+skimID+".assigner");
	}
	
	public String getSkimFunction(String skimID) {
		return props.getProperty("skims."+skimID+".function");
	}
	
	public void removeSkim(String skimID) {
		List<String> ids = getSkimIDs();
		ids.remove(skimID);
		if (!ids.isEmpty()) props.setProperty("skims.ids", String.join(",", ids));
		else props.remove("skims.ids");
		
		Set<String> keys = props.stringPropertyNames();
		for (String key : keys) {
			if (key.startsWith("skims."+skimID)) props.remove(key);
		}
	}

	public void addSkim(String skimID, String assignerID, String skimFunction, String skimSourceURI) {
		List<String> ids = getSkimIDs();
		ids.add(skimID);
		props.setProperty("skims.ids", String.join(",", ids));
		
		props.setProperty("skims."+skimID+".file", skimSourceURI);
		props.setProperty("skims."+skimID+".assigner", assignerID);
		props.setProperty("skims."+skimID+".function", skimFunction);
		
	}

	
	public void setSkimFile(String curSkimID, String text) {
		props.setProperty("skims."+curSkimID+".file", text);
	}
	
	public void setSkimAssigner(String curSkimID, String assignerID) {
		props.setProperty("skims."+curSkimID+".assigner", assignerID);
	}
	
	public void setSkimFunction(String curSkimID, String functionID) {
		props.setProperty("skims."+curSkimID+".function", functionID);
	}
}